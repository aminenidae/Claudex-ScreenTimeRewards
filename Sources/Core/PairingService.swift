import Foundation
import Combine

// MARK: - Pairing Models

/// A pairing code generated by parent to link child device
public struct PairingCode: Codable, Equatable {
    public let code: String
    public let childId: ChildID
    public let createdAt: Date
    public let expiresAt: Date
    public let ttlMinutes: Int
    public let isUsed: Bool
    public let usedAt: Date?
    public let usedByDeviceId: String?

    public init(
        code: String,
        childId: ChildID,
        createdAt: Date = Date(),
        ttlMinutes: Int = 15,
        isUsed: Bool = false,
        usedAt: Date? = nil,
        usedByDeviceId: String? = nil
    ) {
        self.code = code
        self.childId = childId
        self.createdAt = createdAt
        self.ttlMinutes = ttlMinutes
        self.expiresAt = createdAt.addingTimeInterval(TimeInterval(ttlMinutes * 60))
        self.isUsed = isUsed
        self.usedAt = usedAt
        self.usedByDeviceId = usedByDeviceId
    }

    public var isExpired: Bool {
        Date() > expiresAt
    }

    public var isValid: Bool {
        !isUsed && !isExpired
    }

    public func markingUsed(by deviceId: String, at date: Date = Date()) -> PairingCode {
        PairingCode(
            code: code,
            childId: childId,
            createdAt: createdAt,
            ttlMinutes: ttlMinutes,
            isUsed: true,
            usedAt: date,
            usedByDeviceId: deviceId
        )
    }
}

/// A paired child device
public struct ChildDevicePairing: Codable, Equatable, Identifiable {
    public let id: String // deviceId
    public let childId: ChildID
    public let deviceId: String
    public let pairedAt: Date
    public let pairingCode: String // For audit trail

    public init(
        id: String? = nil,
        childId: ChildID,
        deviceId: String,
        pairedAt: Date = Date(),
        pairingCode: String
    ) {
        self.id = id ?? deviceId
        self.childId = childId
        self.deviceId = deviceId
        self.pairedAt = pairedAt
        self.pairingCode = pairingCode
    }
}

// MARK: - Pairing Errors

public enum PairingError: Error, LocalizedError {
    case invalidCode
    case codeExpired
    case codeAlreadyUsed
    case rateLimitExceeded
    case deviceAlreadyPaired
    case noPairingFound

    public var errorDescription: String? {
        switch self {
        case .invalidCode: return "Invalid pairing code"
        case .codeExpired: return "Pairing code has expired"
        case .codeAlreadyUsed: return "Pairing code has already been used"
        case .rateLimitExceeded: return "Too many pairing attempts. Please try again later."
        case .deviceAlreadyPaired: return "This device is already paired to a child"
        case .noPairingFound: return "No pairing found for this device"
        }
    }
}

// MARK: - Pairing Service Protocol

@MainActor
public protocol PairingServiceProtocol {
    /// Generate a new pairing code for a child
    func generatePairingCode(for childId: ChildID, ttlMinutes: Int) throws -> PairingCode

    /// Validate and consume a pairing code
    func consumePairingCode(_ code: String, deviceId: String) throws -> ChildDevicePairing

    /// Get active pairing for a device
    func getPairing(for deviceId: String) -> ChildDevicePairing?

    /// Revoke pairing for a device
    func revokePairing(for deviceId: String) throws

    /// Get all pairings for a child
    func getPairings(for childId: ChildID) -> [ChildDevicePairing]

    /// Get deep link URL for a pairing code
    func deepLinkURL(for code: PairingCode) -> URL

    /// Get the active (unused, unexpired) code for a child if one exists
    func activeCode(for childId: ChildID) -> PairingCode?
}

// MARK: - Pairing Service Implementation

@MainActor
public final class PairingService: ObservableObject, PairingServiceProtocol {

    public static let localPairingDefaultsKey = "com.claudex.localPairing"

    // MARK: Properties

    private var activeCodes: [String: PairingCode] = [:]
    private var pairings: [String: ChildDevicePairing] = [:] // deviceId -> pairing

    // Rate limiting: max 5 code generations per child per hour
    private var generationAttempts: [ChildID: [Date]] = [:]
    private let maxGenerationsPerHour = 5

    // Rate limiting: max 10 validation attempts per device per hour
    private var validationAttempts: [String: [Date]] = [:]
    private let maxValidationsPerHour = 10

    private let persistenceKey = "com.claudex.pairings"
    private let codesKey = "com.claudex.pairingCodes"
    private let generationKey = "com.claudex.pairingGenerationAttempts"
    private let validationKey = "com.claudex.pairingValidationAttempts"
    private let defaults: UserDefaults

    // MARK: Initialization

    public init(userDefaults: UserDefaults = .standard) {
        self.defaults = userDefaults
        loadFromPersistence()
    }

    // MARK: Public Methods

    public func generatePairingCode(for childId: ChildID, ttlMinutes: Int = 15) throws -> PairingCode {
        // Check rate limit
        try checkGenerationRateLimit(for: childId)

        cleanupExpiredCodes()

        // Generate 6-digit code
        let code = generateRandomCode()

        // Ensure only one active code per child
        removeActiveCodes(for: childId)

        // Create pairing code
        let pairingCode = PairingCode(
            code: code,
            childId: childId,
            ttlMinutes: ttlMinutes
        )

        // Store active code
        notifyChange()
        activeCodes[code] = pairingCode

        // Record generation attempt
        recordGenerationAttempt(for: childId)

        // Persist
        saveToPersistence()

        return pairingCode
    }

    public func consumePairingCode(_ code: String, deviceId: String) throws -> ChildDevicePairing {
        // Check rate limit
        try checkValidationRateLimit(for: deviceId)

        // Record validation attempt
        recordValidationAttempt(for: deviceId)

        // Find code
        guard let pairingCode = activeCodes[code] else {
            throw PairingError.invalidCode
        }

        // Validate code
        if pairingCode.isExpired {
            throw PairingError.codeExpired
        }

        if pairingCode.isUsed {
            throw PairingError.codeAlreadyUsed
        }

        // Check if device already paired
        if pairings[deviceId] != nil {
            throw PairingError.deviceAlreadyPaired
        }

        // Mark code as used
        notifyChange()
        activeCodes[code] = pairingCode.markingUsed(by: deviceId)

        // Create pairing
        let pairing = ChildDevicePairing(
            childId: pairingCode.childId,
            deviceId: deviceId,
            pairingCode: code
        )

        // Store pairing
        notifyChange()
        pairings[deviceId] = pairing

        // Persist
        saveToPersistence()

        return pairing
    }

    public func getPairing(for deviceId: String) -> ChildDevicePairing? {
        return pairings[deviceId]
    }

    public func revokePairing(for deviceId: String) throws {
        guard pairings[deviceId] != nil else {
            throw PairingError.noPairingFound
        }

        notifyChange()
        pairings.removeValue(forKey: deviceId)
        saveToPersistence()
    }

    public func getPairings(for childId: ChildID) -> [ChildDevicePairing] {
        return pairings.values.filter { $0.childId == childId }
    }

    public func deepLinkURL(for code: PairingCode) -> URL {
        return URL(string: "claudex://pair/\(code.code)")!
    }

    public func activeCode(for childId: ChildID) -> PairingCode? {
        activeCodes.values.first { $0.childId == childId && !$0.isExpired }
    }

    // MARK: Private Helpers

    private func generateRandomCode() -> String {
        // Generate 6-digit code
        var candidate: String
        repeat {
            candidate = String(Int.random(in: 100000...999999))
        } while activeCodes[candidate] != nil
        return candidate
    }

    private func checkGenerationRateLimit(for childId: ChildID) throws {
        let oneHourAgo = Date().addingTimeInterval(-3600)
        let recentAttempts = generationAttempts[childId]?.filter { $0 > oneHourAgo } ?? []

        if recentAttempts.count >= maxGenerationsPerHour {
            throw PairingError.rateLimitExceeded
        }
    }

    private func recordGenerationAttempt(for childId: ChildID) {
        let oneHourAgo = Date().addingTimeInterval(-3600)
        var attempts = generationAttempts[childId]?.filter { $0 > oneHourAgo } ?? []
        attempts.append(Date())
        generationAttempts[childId] = attempts
    }

    private func checkValidationRateLimit(for deviceId: String) throws {
        let oneHourAgo = Date().addingTimeInterval(-3600)
        let recentAttempts = validationAttempts[deviceId]?.filter { $0 > oneHourAgo } ?? []

        if recentAttempts.count >= maxValidationsPerHour {
            throw PairingError.rateLimitExceeded
        }
    }

    private func recordValidationAttempt(for deviceId: String) {
        let oneHourAgo = Date().addingTimeInterval(-3600)
        var attempts = validationAttempts[deviceId]?.filter { $0 > oneHourAgo } ?? []
        attempts.append(Date())
        validationAttempts[deviceId] = attempts
    }

    // MARK: Persistence

    private func saveToPersistence() {
        // Save pairings
        if let encoded = try? JSONEncoder().encode(Array(pairings.values)) {
            defaults.set(encoded, forKey: persistenceKey)
        }

        // Save active codes
        if let encoded = try? JSONEncoder().encode(Array(activeCodes.values)) {
            defaults.set(encoded, forKey: codesKey)
        }

        if let encoded = try? JSONEncoder().encode(serializeAttempts(generationAttempts)) {
            defaults.set(encoded, forKey: generationKey)
        }

        if let encoded = try? JSONEncoder().encode(validationAttempts) {
            defaults.set(encoded, forKey: validationKey)
        }
    }

    private func loadFromPersistence() {
        // Load pairings
        if let data = defaults.data(forKey: persistenceKey),
           let decoded = try? JSONDecoder().decode([ChildDevicePairing].self, from: data) {
            pairings = Dictionary(uniqueKeysWithValues: decoded.map { ($0.deviceId, $0) })
        }

        // Load active codes
        if let data = defaults.data(forKey: codesKey),
           let decoded = try? JSONDecoder().decode([PairingCode].self, from: data) {
            activeCodes = Dictionary(uniqueKeysWithValues: decoded.map { ($0.code, $0) })
        }

        if let data = defaults.data(forKey: generationKey),
           let decoded = try? JSONDecoder().decode([String: [Date]].self, from: data) {
            generationAttempts = deserializeGenerationAttempts(decoded)
        }

        if let data = defaults.data(forKey: validationKey),
           let decoded = try? JSONDecoder().decode([String: [Date]].self, from: data) {
            validationAttempts = decoded
        }

        // Clean up expired codes
        cleanupExpiredCodes()
    }

    private func cleanupExpiredCodes() {
        notifyChange()
        activeCodes = activeCodes.filter { _, code in
            !code.isExpired
        }
        saveToPersistence()
    }

    private func removeActiveCodes(for childId: ChildID) {
        if activeCodes.values.contains(where: { $0.childId == childId }) {
            notifyChange()
            activeCodes = activeCodes.filter { _, value in
                value.childId != childId
            }
        }
    }

    private func serializeAttempts(_ attempts: [ChildID: [Date]]) -> [String: [Date]] {
        Dictionary(uniqueKeysWithValues: attempts.map { ($0.key.rawValue, $0.value) })
    }

    private func deserializeGenerationAttempts(_ attempts: [String: [Date]]) -> [ChildID: [Date]] {
        Dictionary(uniqueKeysWithValues: attempts.map { (ChildID($0.key), $0.value) })
    }

    private func notifyChange() {
        objectWillChange.send()
    }
}
