import Foundation

// Define a protocol for sync services to avoid circular dependencies
public protocol PairingSyncServiceProtocol {
    func fetchPairingCodes(familyId: FamilyID) async throws -> [PairingCode]
    func savePairingCode(_ code: PairingCode, familyId: FamilyID) async throws
    func deletePairingCode(_ code: String, familyId: FamilyID) async throws
    func fetchDevicePairings(familyId: FamilyID) async throws -> [DevicePairingPayload]
    func saveDevicePairing(_ pairing: DevicePairingPayload, familyId: FamilyID) async throws
    func deleteDevicePairing(deviceId: String, familyId: FamilyID) async throws
}

// Note: CloudKitDebugging protocol and NoOpCloudKitDebugger are now defined in CloudKitDebugger.swift

/// A pairing code generated by parent to link child device
public struct PairingCode: Codable, Equatable {
    public let code: String
    public let childId: ChildID
    public let createdAt: Date
    public let expiresAt: Date
    public let ttlMinutes: Int
    public let isUsed: Bool
    public let usedAt: Date?
    public let usedByDeviceId: String?

    public init(
        code: String,
        childId: ChildID,
        createdAt: Date = Date(),
        ttlMinutes: Int = 15,
        isUsed: Bool = false,
        usedAt: Date? = nil,
        usedByDeviceId: String? = nil
    ) {
        self.code = code
        self.childId = childId
        self.createdAt = createdAt
        self.ttlMinutes = ttlMinutes
        self.expiresAt = createdAt.addingTimeInterval(TimeInterval(ttlMinutes * 60))
        self.isUsed = isUsed
        self.usedAt = usedAt
        self.usedByDeviceId = usedByDeviceId
    }

    public var isExpired: Bool {
        Date() > expiresAt
    }

    public var isValid: Bool {
        !isUsed && !isExpired
    }

    public func markingUsed(by deviceId: String, at date: Date = Date()) -> PairingCode {
        PairingCode(
            code: code,
            childId: childId,
            createdAt: createdAt,
            ttlMinutes: ttlMinutes,
            isUsed: true,
            usedAt: date,
            usedByDeviceId: deviceId
        )
    }
}

public struct FamilyID: Hashable, Codable { public let rawValue: String; public init(_ v: String) { self.rawValue = v } }
public struct ChildID: Hashable, Codable, Sendable { public let rawValue: String; public init(_ v: String) { self.rawValue = v } }

public enum AppClassification: String, Codable { case learning, reward }

/// Identifies whether a device operates as a parent/guardian console or the child's managed device.
public enum DeviceRole: String, Codable, Sendable {
    case parent
    case child
}

// MARK: - CloudKit Sync Models

public struct FamilyPayload: Codable, Equatable {
    public let id: FamilyID
    public let createdAt: Date
    public let parentDeviceIds: [String]?
    public let familyName: String?
    public let modifiedAt: Date

    public init(
        id: FamilyID,
        createdAt: Date = Date(),
        parentDeviceIds: [String]? = nil,
        familyName: String? = nil,
        modifiedAt: Date = Date()
    ) {
        self.id = id
        self.createdAt = createdAt
        self.parentDeviceIds = parentDeviceIds
        self.familyName = familyName
        self.modifiedAt = modifiedAt
    }
}

public struct AppRulePayload: Codable, Equatable {
    public let id: String // {childID}:{appToken}
    public let childId: ChildID
    public let appToken: String
    public let classification: AppClassification
    public let isCategory: Bool
    public let categoryId: String?
    public let createdAt: Date
    public let modifiedAt: Date
    public let modifiedBy: String? // Parent device ID

    public init(
        id: String,
        childId: ChildID,
        appToken: String,
        classification: AppClassification,
        isCategory: Bool = false,
        categoryId: String? = nil,
        createdAt: Date = Date(),
        modifiedAt: Date = Date(),
        modifiedBy: String? = nil
    ) {
        self.id = id
        self.childId = childId
        self.appToken = appToken
        self.classification = classification
        self.isCategory = isCategory
        self.categoryId = categoryId
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
    }
}

public struct ChildContextPayload: Codable, Equatable {
    public let id: ChildID
    public let childOpaqueId: String
    public let displayName: String?
    public let pairedDeviceIds: [String]

    public init(
        id: ChildID,
        childOpaqueId: String,
        displayName: String? = nil,
        pairedDeviceIds: [String] = []
    ) {
        self.id = id
        self.childOpaqueId = childOpaqueId
        self.displayName = displayName
        self.pairedDeviceIds = pairedDeviceIds
    }
}

public struct AppIdentifier: Hashable, Codable, Sendable {
    public let rawValue: String
    public init(_ rawValue: String) { self.rawValue = rawValue }
}

public struct ChildAppInventoryPayload: Codable, Equatable {
    public let id: String // {childID}:{deviceID}
    public let childId: ChildID
    public let deviceId: String
    public let appTokens: [String] // Base64-encoded ApplicationTokens
    public let categoryTokens: [String] // Base64-encoded CategoryTokens
    public let lastUpdated: Date
    public let appCount: Int

    public init(
        id: String,
        childId: ChildID,
        deviceId: String,
        appTokens: [String] = [],
        categoryTokens: [String] = [],
        lastUpdated: Date = Date(),
        appCount: Int = 0
    ) {
        self.id = id
        self.childId = childId
        self.deviceId = deviceId
        self.appTokens = appTokens
        self.categoryTokens = categoryTokens
        self.lastUpdated = lastUpdated
        self.appCount = appCount
    }
}

public struct DevicePairingPayload: Codable, Equatable {
    public let id: String
    public let childId: ChildID?
    public let deviceId: String
    public let deviceName: String
    public let deviceRole: DeviceRole
    public let pairedAt: Date
    public let familyId: FamilyID?

    public init(
        id: String,
        childId: ChildID?,
        deviceId: String,
        deviceName: String,
        deviceRole: DeviceRole,
        pairedAt: Date = Date(),
        familyId: FamilyID?
    ) {
        self.id = id
        self.childId = childId
        self.deviceId = deviceId
        self.deviceName = deviceName
        self.deviceRole = deviceRole
        self.pairedAt = pairedAt
        self.familyId = familyId
    }
}

public struct PointsLedgerEntry: Codable, Identifiable, Sendable {
    public enum EntryType: String, Codable { case accrual, redemption, adjustment }
    public let id: UUID
    public let childId: ChildID
    public let appId: AppIdentifier?
    public let type: EntryType
    public let amount: Int
    public let timestamp: Date
    public init(
        id: UUID = .init(),
        childId: ChildID,
        appId: AppIdentifier? = nil,
        type: EntryType,
        amount: Int,
        timestamp: Date = .init()
    ) {
        self.id = id
        self.childId = childId
        self.appId = appId
        self.type = type
        self.amount = amount
        self.timestamp = timestamp
    }
}

public struct UsageSession: Codable, Identifiable {
    public let id: UUID
    public let childId: ChildID
    public let appId: AppIdentifier?
    public let startTime: Date
    public var endTime: Date?
    public var lastActivityTime: Date
    public var durationSeconds: TimeInterval {
        let end = endTime ?? Date()
        return max(0, end.timeIntervalSince(startTime))
    }

    public init(
        id: UUID = .init(),
        childId: ChildID,
        appId: AppIdentifier? = nil,
        startTime: Date = .init(),
        endTime: Date? = nil,
        lastActivityTime: Date = .init()
    ) {
        self.id = id
        self.childId = childId
        self.appId = appId
        self.startTime = startTime
        self.endTime = endTime
        self.lastActivityTime = lastActivityTime
    }
}

public struct PointsConfiguration: Codable {
    public let pointsPerMinute: Int
    public let dailyCapPoints: Int
    public let idleTimeoutSeconds: TimeInterval

    public init(pointsPerMinute: Int = 10, dailyCapPoints: Int = 600, idleTimeoutSeconds: TimeInterval = 180) {
        self.pointsPerMinute = pointsPerMinute
        self.dailyCapPoints = dailyCapPoints
        self.idleTimeoutSeconds = idleTimeoutSeconds
    }

    public static let `default` = PointsConfiguration()
}

public struct PerAppPointsRule: Codable, Equatable {
    public var pointsPerMinute: Int
    public var dailyCapPoints: Int
    public var idleTimeoutSeconds: TimeInterval

    public init(pointsPerMinute: Int = 10, dailyCapPoints: Int = 600, idleTimeoutSeconds: TimeInterval = 180) {
        self.pointsPerMinute = pointsPerMinute
        self.dailyCapPoints = dailyCapPoints
        self.idleTimeoutSeconds = idleTimeoutSeconds
    }

    public static let `default` = PerAppPointsRule()
}

public struct RedemptionConfiguration: Codable {
    public let pointsPerMinute: Int        // Points required per minute of earned time
    public let minRedemptionPoints: Int    // Minimum points to redeem
    public let maxRedemptionPoints: Int    // Maximum points per redemption
    public let maxTotalMinutes: Int        // Max accumulated earned time (for stacking)

    public init(
        pointsPerMinute: Int = 10,
        minRedemptionPoints: Int = 30,
        maxRedemptionPoints: Int = 600,
        maxTotalMinutes: Int = 120
    ) {
        self.pointsPerMinute = pointsPerMinute
        self.minRedemptionPoints = minRedemptionPoints
        self.maxRedemptionPoints = maxRedemptionPoints
        self.maxTotalMinutes = maxTotalMinutes
    }

    public static let `default` = RedemptionConfiguration()
}

public struct PerAppRewardRule: Codable, Equatable {
    public var pointsPerMinute: Int
    public var minRedemptionPoints: Int
    public var maxRedemptionPoints: Int
    public var stackingPolicy: ExemptionStackingPolicy

    public init(
        pointsPerMinute: Int = 10,
        minRedemptionPoints: Int = 30,
        maxRedemptionPoints: Int = 600,
        stackingPolicy: ExemptionStackingPolicy = .replace
    ) {
        self.pointsPerMinute = pointsPerMinute
        self.minRedemptionPoints = minRedemptionPoints
        self.maxRedemptionPoints = maxRedemptionPoints
        self.stackingPolicy = stackingPolicy
    }

    public static let `default` = PerAppRewardRule()
}

public struct EarnedTimeWindow: Codable, Identifiable {
    public let id: UUID
    public let childId: ChildID
    public let durationSeconds: TimeInterval
    public let startTime: Date

    public var endTime: Date {
        startTime.addingTimeInterval(durationSeconds)
    }

    public var remainingSeconds: TimeInterval {
        max(0, endTime.timeIntervalSince(Date()))
    }

    public var isExpired: Bool {
        Date() >= endTime
    }

    public init(
        id: UUID = .init(),
        childId: ChildID,
        durationSeconds: TimeInterval,
        startTime: Date = .init()
    ) {
        self.id = id
        self.childId = childId
        self.durationSeconds = durationSeconds
        self.startTime = startTime
    }
}

public enum ExemptionStackingPolicy: String, Codable {
    case replace        // New redemption replaces current window
    case extend         // Add time to existing window (respects max)
    case queue          // Queue next window after current expires
    case block          // Prevent redemption until current expires
}

// MARK: - Protocols

@MainActor
public protocol PointsLedgerProtocol {
    func recordAccrual(childId: ChildID, appId: AppIdentifier?, points: Int, timestamp: Date) -> PointsLedgerEntry
    func recordRedemption(childId: ChildID, appId: AppIdentifier?, points: Int, timestamp: Date) -> PointsLedgerEntry
    func recordAdjustment(childId: ChildID, appId: AppIdentifier?, points: Int, reason: String, timestamp: Date) -> PointsLedgerEntry
    func getBalance(childId: ChildID) -> Int
    func getBalance(childId: ChildID, appId: AppIdentifier) -> Int
    func getBalances(childId: ChildID) -> [AppIdentifier: Int]
    func getEntries(childId: ChildID) -> [PointsLedgerEntry]
    func getEntries(childId: ChildID, limit: Int?) -> [PointsLedgerEntry]
    func getEntriesInRange(childId: ChildID, from: Date, to: Date) -> [PointsLedgerEntry]
}

public extension PointsLedgerProtocol {
    func recordAccrual(childId: ChildID, points: Int, timestamp: Date = Date()) -> PointsLedgerEntry {
        recordAccrual(childId: childId, appId: nil, points: points, timestamp: timestamp)
    }

    func recordRedemption(childId: ChildID, points: Int, timestamp: Date = Date()) -> PointsLedgerEntry {
        recordRedemption(childId: childId, appId: nil, points: points, timestamp: timestamp)
    }

    func recordAdjustment(childId: ChildID, points: Int, reason: String, timestamp: Date = Date()) -> PointsLedgerEntry {
        recordAdjustment(childId: childId, appId: nil, points: points, reason: reason, timestamp: timestamp)
    }
}
